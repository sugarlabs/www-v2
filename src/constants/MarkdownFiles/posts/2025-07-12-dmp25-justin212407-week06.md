---
title: "DMP’25 Week 06 Update by Justin Charles"
excerpt: "Added drag and drop support from palette to workspace, rendered interactive blocks, and built a collision map with linear and quad tree detection"
category: "DEVELOPER NEWS"
date: "2025-07-13"
slug: "2025-07-13-dmp-25-justin212407-week06"
author: "@/constants/MarkdownFiles/authors/justin-charles.md"
tags: "dmp25,sugarlabs,week6,justin212407"
image: "assets/Images/c4gt_DMP.png"
---

<!-- markdownlint-disable -->

# Week 5 Progress Report by Justin Charles

**Project:** Music Blocks 4 Masonry  
**Mentors:** [Anindya Kundu](https://github.com/meganindya/), [Sumit Srivastava](https://github.com/sum2it)  
**Assisting Mentors:** [Devin Ulibari](https://github.com/pikurasa/), [Walter Bender](https://github.com/walterbender)  
**Reporting Period:** 2025-06-06 - 2025-07-13   

---

## Goals for This Week

- Add React Aria and Recoil for State Management of bricks in WorkSpace  
- Generate a real-time collision map tracking overlapping bricks  
- Implement and compare two spatial collision algorithms: linear scan and quadtree  

---

## This Week’s Highlights

### 1. **Add React Aria and Recoil for State Management of bricks in WorkSpace**

Enabled Smooth dragging of Bricks in and around the workspace using React Aria and Recoil:
- Created Draggable components for bricks to make them move in the workspace.
- Update State and position of bricks each time it is updated and moved. 

### 2. **Collision Map Infrastructure**

Created a collision detection engine to register overlapping bricks:
- On each render/update, all bounding boxes are passed into the collision space
- Outputs collision pairs with `id` references
- Visual debug overlay available to inspect overlaps

Supports both brute-force and spatial-partitioned (quadtree) strategies via strategy pattern  

### 3. **Implemented Two Collision Detection Algorithms**

**a. Linear Brute-Force Algorithm**  
- O(n) pairwise check between all visible bricks  
- Ideal for ≤ 20 bricks  

**b. Quad Tree Algorithm**  
- Spatially partitions the workspace into quadrants recursively  
- Reduces unnecessary checks by limiting comparisons to nearby bricks  
- Scales well to large projects  

---

## Challenges & Solutions

**Challenge:** Drag offsets weren’t accurate when dropping bricks inside nested towers  
**Solution:** Used bounding client rect and scroll offsets to normalize cursor position  

**Challenge:** Collision map flickered on high-frequency updates  
**Solution:** Debounced update cycle and implemented memoized collision bounding box comparison  

---

## Key Learnings

- **Drag and Drop Mechanics**  
  Learned native drag/drop lifecycle (dragstart, dragover, drop) and integrating with component state

- **Spatial Algorithms**  
  Compared brute-force vs quadtree models and saw practical scaling tradeoffs in the playground

- **State-Driven Rendering**  
  Deepened understanding of how Recoil-based atom changes trigger dynamic rendering in React  

---
## Mid Term Summary: 

**Week 01**
The first week was dedicated to understanding the core geometry behind the SVG path rendering of bricks. I focused on identifying constants required to construct the outlines of different brick types and reverse-engineered how variable features like notches or arguments influenced the structure. This involved translating SVG commands into modular logic and laying the groundwork for a parameter-driven rendering system that would scale across all types of bricks.

**Week 02**
Building on the SVG foundation, I completed the path generation logic for all three core brick types — Simple, Expression, and Compound. I also categorized all props and visual states a brick can have and documented the variations clearly across types. With the rendering engine in place, I authored a comprehensive test suite to ensure output correctness and visual consistency, setting the stage for a stable rendering system.

**Week 03**
This week marked the shift from static SVG rendering to dynamic tree-based rendering. I built a recursive parser that transformed a brick tree structure into React components, preserving hierarchy and sibling order. Additionally, I exposed spatial data like bounding boxes and connection points from the model layer and passed them through the rendering pipeline, allowing for downstream layout and interaction logic to be implemented in a clean, scalable way.

**Week 04**
I focused on creating the palette system by compiling all brick types from the source code and organizing them into a visual schema. A JSON schema was also defined to ensure consistency across brick definitions. This schema was then used to power a dynamic, searchable, and category-aware Palette UI. It enabled brick previews and made the rendering layer schema-driven, simplifying future maintenance and scalability.

**Week 05**
The main highlight this week was setting up the interactive playground. I created the workspace layout and integrated the palette directly into it. I implemented full drag-and-drop functionality allowing bricks to be dragged from the palette and dropped into the canvas. On drop, brick metadata was used to create a model instance at the appropriate position. This built the bridge between UI interaction and the underlying data model.

**Week 06**
The focus shifted to interactivity and spatial intelligence. I enabled in-canvas dragging of placed bricks using React Aria and Recoil. Alongside that, I built a collision detection engine capable of detecting overlapping bricks. Two algorithms were implemented: a simple linear scan and a performance-optimized quadtree. This introduced real-time spatial awareness into the system and laid the groundwork for advanced features like snapping, grouping, and constraint-based layouts.


## Next Week’s Roadmap

- Enable snapping logic during drag-drop using collision hints  
- Highlight drop zones using bounding box heatmaps  

---

## Resources & References

- [musicblocks-v4 Repository](https://github.com/sugarlabs/musicblocks-v4)  
- [Quadtree Implementation Ref](https://en.wikipedia.org/wiki/Quadtree)  
- [Collision Detection Implementation Plan](https://docs.google.com/document/d/1C0t4iSze2eDEv6lWbloK3MnvJgAa6HvmXmk2sQ0lCZs/edit?tab=t.ma5nmu1mlnke#heading=h.esqcxx854myo)

---

## Acknowledgments

Thanks to my mentor Anindya Kundu for for the consistent feedback and support.

---
